// game-bin_bind_0000.c
// Generated by decompiling game-bin
// using Reko decompiler version 0.10.0.0.

#include "game-bin.h"

// 08CF9190: void fn08CF9190(Stack word32 dwArg00)
void fn08CF9190(word32 dwArg00)
{
	fn08CF9195(dwLoc04);
	fn08CF9195(dwArg00);
}

// 08CF9195: void fn08CF9195(Stack word32 dwArg00)
// Called from:
//      fn08CF9190
void fn08CF9195(word32 dwArg00)
{
	__align(fp - 28);
	fn08CF91F2(dwArg00 - 0x05);
}

// 08CF91F2: void fn08CF91F2(Stack (ptr32 Eq_231) dwArg04)
// Called from:
//      fn08CF9195
void fn08CF91F2(struct Eq_231 * dwArg04)
{
	word128 xmm0_16 = dwArg04->owFFFFFF40;
	word128 xmm0_19 = dwArg04->owFFFFFF50;
	word128 xmm0_21 = dwArg04->owFFFFFF60;
	word32 dwLoc0198_1598 = SLICE(xmm0_16, word32, 32);
	word32 ecx_18 = (word32) xmm0_16;
	ui32 dwLoc018C_1600 = (word32) xmm0_19;
	int32 dwLoc0188_1603 = SLICE(xmm0_19, word32, 32);
	word32 dwLoc0184_1977 = SLICE(xmm0_19, word32, 64);
	word32 dwLoc0178_1624 = SLICE(xmm0_21, word32, 32);
	int32 dwLoc017C_1628 = (word32) xmm0_21;
	Eq_261 dwLoc0170_1811 = SLICE(xmm0_21, word32, 96);
	int32 dwLoc0174_1825 = SLICE(xmm0_21, word32, 64);
	ui32 dwLoc0160_1906 = dwArg04->dw009C;
	word32 dwLocEC_1671 = dwArg04->dw0010;
	word32 * edx_43 = fp - 0x0198;
	while (true)
	{
		word32 eax_46 = *edx_43;
		*edx_43 = ecx_18 ^ eax_46;
		++edx_43;
		if (edx_43 == fp - 220)
			break;
		ecx_18 = eax_46;
	}
	if (dwLoc0198_1598 != 3235823838)
	{
l08CF92EF:
		while (true)
			__syscall(0x03);
	}
	Eq_292 ebp_83 = dwLoc0178_1624 + 0x0F & ~0x0F;
	if (ebp_83 > 0x0280)
		goto l08CF92EF;
	Eq_292 dwLoc0444_1630;
	byte * edi_107;
	ptr32 edx_89 = dwArg04 - dwLoc0188_1603;
	byte * edx_134 = edx_89 + dwLoc017C_1628;
	Eq_292 ecx_96 = __align(ebp_83, 16);
	if (ebp_83 > 0x0F && ecx_96 != 0x00)
	{
		Eq_323 edi_109 = dwArg04 + (dwLoc017C_1628 - dwLoc0188_1603) / 0x00A0;
		uint32 dwLoc0444_1633 = 0x00;
		int32 edi_114 = 0x00;
		do
		{
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x041C)[edi_114 / 16].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_331) *((word32) edi_109 + edi_114);
			uint32 v15_125 = dwLoc0444_1633 + 0x01;
			dwLoc0444_1633 = v15_125;
			edi_114 += 0x10;
		} while (v15_125 < ebp_83 >> 0x04);
		edx_134 += ecx_96;
		byte * edi_136 = (word32) ecx_96 + (fp - 0x041C);
		dwLoc0444_1630 = ebp_83 - ecx_96;
		if (ebp_83 == ecx_96)
		{
l08CF946E:
			word32 eax_1550 = eax_46;
			uint32 edi_161 = ebp_83 >> 0x02;
			if (ebp_83 >> 0x02 != 0x00)
			{
				word32 * edx_166 = fp - 0x041C;
				while (true)
				{
					word32 ecx_169 = *edx_166;
					*edx_166 = eax_1550 ^ ecx_169;
					++edx_166;
					--edi_161;
					if (edi_161 == 0x00)
						break;
					eax_1550 = ecx_169;
				}
			}
			word32 * edx_181 = fp - 0xB0;
			byte * eax_184 = fp - 0x041C;
			byte * ecx_186 = dwLoc0178_1624 + (fp - 0x041C);
l08CF94A3:
			if (ecx_186 > eax_184)
			{
				*edx_181 = eax_184;
				do
				{
					if (*eax_184 == 0x00)
					{
						++eax_184;
						++edx_181;
						if (edx_181 != fp - 0x70)
							goto l08CF94A3;
						if (eax_184 != ecx_186)
							break;
						ptr32 edi_222 = dwArg04 - dwLoc018C_1600;
						<anonymous> * eax_225 = dwLocEC_1671 + edi_222;
						<anonymous> * eax_246;
						eax_225();
						if (eax_246 == null)
							break;
						<anonymous> * eax_257;
						fn00000000();
						if (eax_257 == null)
							break;
						word32 eax_268;
						eax_225();
						if (eax_268 == 0x00)
							break;
						word32 eax_279;
						eax_225();
						if (eax_279 == 0x00)
							break;
						word32 eax_290;
						eax_225();
						if (eax_290 == 0x00)
							break;
						word32 eax_301;
						fn00000000();
						if (eax_301 == 0x00)
							break;
						word32 eax_312;
						eax_225();
						if (eax_312 == 0x00)
							break;
						<anonymous> * eax_323;
						eax_225();
						if (eax_323 == null)
							break;
						word32 eax_334;
						eax_225();
						if (eax_334 == 0x00)
							break;
						<anonymous> * eax_345;
						fn00000000();
						if (eax_345 == null)
							break;
						int32 dwLoc044C_1817;
						byte al_1271;
						Eq_458 eax_356;
						eax_246();
						if (eax_356 == 0x00)
						{
							dwLoc044C_1817 = 0x57;
							al_1271 = 0x57;
							goto l08CF9879;
						}
						Eq_261 ecx_371;
						if (dwLoc0170_1811 == 0x00)
						{
							&ecx_371.u0->t0000 = 0x00;
							goto l08CF9AE3;
						}
						Eq_261 dwLoc044C_1853;
						Eq_458 ecx_411;
						byte * edx_377 = edx_89 + dwLoc0174_1825;
						word128 * ecx_379 = dwArg04 + (dwLoc0174_1825 - dwLoc0188_1603) / 0x00A0;
						Eq_261 ecx_384 = __align(dwLoc0170_1811, 16);
						if (ecx_384 != 0x00 && (CONVERT(dwLoc0170_1811 >u 0x0F, bool, int8) & (CONVERT(eax_356 >u ecx_379 + 0x10, bool, int8) | CONVERT(ecx_379 >u eax_356 + 0x10, bool, int8))) != 0x00)
						{
							word128 * ecx_414 = null;
							uint32 dwLoc044C_1854 = 0x00;
							do
							{
								Mem425[eax_356 + ecx_414:word128] = Mem420[ecx_379 + ecx_414:word128];
								uint32 v19_426 = dwLoc044C_1854 + 0x01;
								dwLoc044C_1854 = v19_426;
								ecx_414 += 0x10;
							} while (v19_426 < dwLoc0170_1811 >> 0x04);
							edx_377 += ecx_384;
							word32 ecx_436 = ecx_384 + eax_356;
							dwLoc044C_1853 = dwLoc0170_1811 - ecx_384;
							if (dwLoc0170_1811 == ecx_384)
								goto l08CF976E;
							ecx_411 = ecx_436;
						}
						else
						{
							ecx_411 = eax_356;
							dwLoc044C_1853 = dwLoc0170_1811;
						}
						do
						{
							*ecx_411 = *edx_377;
							Eq_261 v21_453 = dwLoc044C_1853 - 0x01;
							ecx_411 = (word32) ecx_411 + 1;
							++edx_377;
							dwLoc044C_1853 = v21_453;
						} while (v21_453 != 0x00);
l08CF976E:
						ecx_371 = dwLoc0170_1811;
						if (dwLoc0170_1811 >> 0x03 != 0x00)
						{
							uint32 dwLoc0448_1872 = 0x55555555;
							uint32 dwLoc0440_1873 = 0x55555555;
							ui32 eax_469 = 0x00;
							while (true)
							{
								uint32 ebp_488 = *((word32) eax_356 + (eax_469 * 0x08 + 4));
								uint32 esi_485 = *((word32) eax_356 + eax_469 * 0x08);
								uint32 ecx_490 = ebp_488;
								uint32 edx_491 = 3337565984;
								esi_502 = esi_485;
								do
								{
									uint32 esi_502;
									edx_491 += 0x61C88647;
									ecx_490 -= (fp - 0x0114)[edx_491 >> 11 & 0x03] + edx_491 ^ (esi_502 >> 0x05 ^ esi_502 << 0x04) + esi_502;
									esi_502 -= (fp - 0x0114)[edx_491 & 0x03] + edx_491 ^ (ecx_490 >> 0x05 ^ ecx_490 << 0x04) + ecx_490;
								} while (edx_491 != 0x00);
								*((word32) eax_356 + eax_469 * 0x08) = esi_502 ^ dwLoc0440_1873;
								*((word32) eax_356 + (eax_469 * 0x08 + 4)) = ecx_490 ^ dwLoc0448_1872;
								++eax_469;
								if (eax_469 + 0x01 == dwLoc0170_1811 >> 0x03)
									break;
								dwLoc0448_1872 = ebp_488;
								dwLoc0440_1873 = esi_485;
							}
							ecx_371 = dwLoc0170_1811;
						}
l08CF9AE3:
						ui32 eax_1022 = 0x00;
						Eq_292 ecx_562 = 0x00;
						do
						{
							int32 edx_570 = (word32) *((word32) ecx_562 + (fp - 0x041C)) << 0x18 ^ eax_1022;
							int32 eax_571 = edx_570 * 0x02;
							if (edx_570 < 0x00)
								eax_571 = edx_570 * 0x02 ^ 0x488781ED;
							int32 edx_579 = eax_571 * 0x02;
							if (eax_571 < 0x00)
								edx_579 = edx_579 ^ 0x488781ED;
							int32 eax_587 = edx_579 * 0x02;
							if (edx_579 < 0x00)
								eax_587 = eax_587 ^ 0x488781ED;
							int32 edx_595 = eax_587 * 0x02;
							if (eax_587 < 0x00)
								edx_595 = edx_595 ^ 0x488781ED;
							int32 eax_603 = edx_595 * 0x02;
							if (edx_595 < 0x00)
								eax_603 = eax_603 ^ 0x488781ED;
							int32 edx_611 = eax_603 * 0x02;
							if (eax_603 < 0x00)
								edx_611 = edx_611 ^ 0x488781ED;
							int32 eax_619 = edx_611 * 0x02;
							if (edx_611 < 0x00)
								eax_619 = eax_619 ^ 0x488781ED;
							ui32 edx_627 = eax_619 * 0x02;
							eax_1022 = edx_627;
							if (eax_619 < 0x00)
								eax_1022 = edx_627 ^ 0x488781ED;
							ecx_562 = (word32) ecx_562 + 1;
						} while (ebp_83 > ecx_562);
						int32 ebp_656 = 0x00;
						do
						{
							int32 edx_667 = (word32) (ebp_656 + (fp - 0x019C)) << 0x18 ^ eax_1022;
							int32 eax_668 = edx_667 * 0x02;
							if (edx_667 < 0x00)
								eax_668 = edx_667 * 0x02 ^ 0x488781ED;
							int32 edx_676 = eax_668 * 0x02;
							if (eax_668 < 0x00)
								edx_676 = edx_676 ^ 0x488781ED;
							int32 eax_684 = edx_676 * 0x02;
							if (edx_676 < 0x00)
								eax_684 = eax_684 ^ 0x488781ED;
							int32 edx_692 = eax_684 * 0x02;
							if (eax_684 < 0x00)
								edx_692 = edx_692 ^ 0x488781ED;
							int32 eax_700 = edx_692 * 0x02;
							if (edx_692 < 0x00)
								eax_700 = eax_700 ^ 0x488781ED;
							int32 edx_708 = eax_700 * 0x02;
							if (eax_700 < 0x00)
								edx_708 = edx_708 ^ 0x488781ED;
							int32 eax_716 = edx_708 * 0x02;
							if (edx_708 < 0x00)
								eax_716 = eax_716 ^ 0x488781ED;
							ui32 edx_724 = eax_716 * 0x02;
							eax_1022 = edx_724 ^ 0x488781ED;
							if (eax_716 >= 0x00)
								eax_1022 = edx_724;
							++ebp_656;
							word16 ebp_16_16_1555 = SLICE(ebp_656, word16, 16);
						} while (ebp_656 != 0xC0);
						int32 edx_762 = dwLoc0184_1977 + 0x0F & ~0x0F;
						if (edx_762 != 0x00)
						{
							int32 ebp_1556 = SEQ(ebp_16_16_1555, 0x00);
							do
							{
								int32 edx_777 = (word32) dwArg04[ebp_1556 / 0x00A0] << 0x18 ^ eax_1022;
								int32 eax_778 = edx_777 * 0x02;
								if (edx_777 < 0x00)
									eax_778 = edx_777 * 0x02 ^ 0x488781ED;
								int32 edx_786 = eax_778 * 0x02;
								if (eax_778 < 0x00)
									edx_786 = edx_786 ^ 0x488781ED;
								int32 eax_794 = edx_786 * 0x02;
								if (edx_786 < 0x00)
									eax_794 = eax_794 ^ 0x488781ED;
								int32 edx_802 = eax_794 * 0x02;
								if (eax_794 < 0x00)
									edx_802 = edx_802 ^ 0x488781ED;
								int32 eax_810 = edx_802 * 0x02;
								if (edx_802 < 0x00)
									eax_810 = eax_810 ^ 0x488781ED;
								int32 edx_818 = eax_810 * 0x02;
								if (eax_810 < 0x00)
									edx_818 = edx_818 ^ 0x488781ED;
								int32 eax_826 = edx_818 * 0x02;
								if (edx_818 < 0x00)
									eax_826 = eax_826 ^ 0x488781ED;
								ui32 edx_834 = eax_826 * 0x02;
								eax_1022 = edx_834 ^ 0x488781ED;
								if (eax_826 >= 0x00)
									eax_1022 = edx_834;
								++ebp_1556;
							} while (ebp_1556 != edx_762);
						}
						if (ecx_371 != 0x00)
						{
							Eq_261 ebp_875 = 0x00;
							do
							{
								word32 edx_914 = CONVERT(Mem907[eax_356 + ebp_875:byte], byte, word32) << 0x18 ^ eax_1022;
								int32 eax_915 = edx_914 * 0x02;
								if (edx_914 < 0x00)
									eax_915 = edx_914 * 0x02 ^ 0x488781ED;
								int32 edx_923 = eax_915 * 0x02;
								if (eax_915 < 0x00)
									edx_923 = edx_923 ^ 0x488781ED;
								int32 eax_931 = edx_923 * 0x02;
								if (edx_923 < 0x00)
									eax_931 = eax_931 ^ 0x488781ED;
								int32 edx_939 = eax_931 * 0x02;
								if (eax_931 < 0x00)
									edx_939 = edx_939 ^ 0x488781ED;
								int32 eax_947 = edx_939 * 0x02;
								if (edx_939 < 0x00)
									eax_947 = eax_947 ^ 0x488781ED;
								int32 edx_955 = eax_947 * 0x02;
								if (eax_947 < 0x00)
									edx_955 = edx_955 ^ 0x488781ED;
								int32 eax_963 = edx_955 * 0x02;
								if (edx_955 < 0x00)
									eax_963 = eax_963 ^ 0x488781ED;
								ui32 edx_971 = eax_963 * 0x02;
								eax_1022 = edx_971 ^ 0x488781ED;
								if (eax_963 >= 0x00)
									eax_1022 = edx_971;
								ebp_875 = (word32) ebp_875 + 1;
							} while (ebp_875 != ecx_371);
						}
						if (dwLoc0160_1906 != eax_1022)
						{
							dwLoc044C_1817 = 0x51;
							al_1271 = 0x51;
							goto l08CF9879;
						}
						struct Eq_974 * eax_1077 = fn08CFA28E(fp - 220, eax_356, ecx_371, 0x00);
						if (dwLoc0170_1811 != 0x00)
						{
							Eq_989 ebp_1091 = -eax_356;
							Eq_261 ebp_1092 = ebp_1091 & 0x0F;
							if ((ebp_1091 & 0x0F) > dwLoc0170_1811)
								ebp_1092 = dwLoc0170_1811;
							Eq_261 edx_1097 = dwLoc0170_1811;
							Eq_458 eax_1099 = eax_356;
							if (ebp_1092 != 0x00)
							{
								Eq_261 dwLoc0440_2099 = 0x00;
								do
								{
									*eax_1099 = 0x00;
									Eq_261 v27_1112 = (word32) dwLoc0440_2099 + 1;
									++eax_1099;
									--edx_1097;
									dwLoc0440_2099 = v27_1112;
								} while (ebp_1092 > v27_1112);
								if (dwLoc0170_1811 != ebp_1092)
									goto l08CF9E38;
								goto l08CF9E8C;
							}
l08CF9E38:
							Eq_1014 ecx_1122 = dwLoc0170_1811 - ebp_1092;
							Eq_1014 ecx_1127 = __align(ecx_1122, 16);
							if (ecx_1127 != 0x00)
							{
								word32 ebp_1132 = ebp_1092 + eax_356;
								uint32 dwLoc0440_2104 = 0x00;
								do
								{
									*ebp_1132 = 0x00;
									uint32 v28_1143 = dwLoc0440_2104 + 0x01;
									dwLoc0440_2104 = v28_1143;
									++ebp_1132;
								} while (v28_1143 < ecx_1122 >> 0x04);
								eax_1099 += ecx_1127;
								edx_1097 -= ecx_1127;
								if (ecx_1122 != ecx_1127)
									goto l08CF9E81;
							}
							else
							{
l08CF9E81:
								do
								{
									*eax_1099 = 0x00;
									++eax_1099;
									--edx_1097;
								} while (edx_1097 != 0x00);
							}
						}
l08CF9E8C:
						eax_257();
						if (eax_1077 == null)
						{
							dwLoc044C_1817 = 66;
							al_1271 = 66;
							goto l08CF9879;
						}
						<anonymous> * eax_1244 = fn08CFA144(eax_1077, null);
						if (eax_1244 == null)
						{
							dwLoc044C_1817 = 0x43;
							al_1271 = 0x43;
l08CF9879:
							goto l08CF9884;
						}
						else
						{
							word32 eax_1264;
							eax_1244();
							al_1271 = (byte) eax_1264;
							if (al_1271 == 0x30)
								fn08CFA1AF(fp - 220, eax_1077);
							else
							{
								dwLoc044C_1817 = 0x35;
								if (al_1271 != 0x35)
								{
									dwLoc044C_1817 = (int32) al_1271;
l08CF9884:
									if (al_1271 != 0x45)
									{
										word32 esi_1292 = (word32) null;
										byte * edi_1291 = null;
										byte * ecx_1298 = fp - 44;
										while ((byte) esi_1292 != 0x00)
										{
											*ecx_1298 = (byte) esi_1292;
											++edi_1291;
											esi_1292 = (word32) *edi_1291;
											++ecx_1298;
										}
										*ecx_1298 = 0x00;
										word32 edi_1321 = (word32) null;
										byte * ebp_1320 = null;
										byte * ecx_1327 = fp - 0x6C;
										while ((byte) edi_1321 != 0x00)
										{
											*ecx_1327 = (byte) edi_1321;
											++ebp_1320;
											edi_1321 = (word32) *ebp_1320;
											++ecx_1327;
										}
										*ecx_1327 = 0x00;
										int32 ecx_1349 = 0x00;
										if (bLoc6C != 0x00)
										{
											do
												++ecx_1349;
											while (fp - 0x6C + ecx_1349 != 0x00);
										}
										struct Eq_723 * ecx_1363 = ecx_1349 + (fp - 0x6C);
										while (true)
										{
											struct Eq_723 * edi_1366 = ecx_1363 - 0x01;
											if (edi_1366 <= fp - 0x6C)
												break;
											if (ecx_1363->bFFFFFFFF == 0x3A)
											{
												ecx_1363->bFFFFFFFE = al_1271;
												ecx_1363->b0000 = 0x30;
												ecx_1363[1] = (struct Eq_723) 0x30;
												ecx_1363[2] = (struct Eq_723) 0x30;
												ecx_1363[3] = (struct Eq_723) 0x30;
												ecx_1363[4] = (struct Eq_723) 0x30;
												ecx_1363[5] = (struct Eq_723) 0x36;
												ecx_1363[6] = (struct Eq_723) 55;
												ecx_1363[7] = (struct Eq_723) 0x34;
												ecx_1363[8] = (struct Eq_723) 0x33;
												ecx_1363[9] = (struct Eq_723) 0x31;
												break;
											}
											ecx_1363 = edi_1366;
										}
										int32 eax_1389 = 0x00;
										if (bLoc2C != 0x00)
										{
											do
												++eax_1389;
											while (fp - 44 + eax_1389 != 0x00);
										}
										eax_345();
										int32 eax_1428 = 0x00;
										if (bLoc6C != 0x00)
										{
											do
												++eax_1428;
											while (fp - 0x6C + eax_1428 != 0x00);
										}
										eax_345();
									}
								}
								word128 * eax_1488 = fp - 0x041C;
								do
								{
									*eax_1488 = 0x00;
									++eax_1488;
								} while (eax_1488 != fp - 0x019C);
								eax_323();
							}
							return;
						}
					}
					++eax_184;
				} while (eax_184 != ecx_186);
			}
			goto l08CF92EF;
		}
		edi_107 = edi_136;
	}
	else
	{
		dwLoc0444_1630 = ebp_83;
		edi_107 = fp - 0x041C;
	}
	do
	{
		*edi_107 = *edx_134;
		Eq_292 v17_154 = dwLoc0444_1630 - 0x01;
		++edi_107;
		++edx_134;
		dwLoc0444_1630 = v17_154;
	} while (v17_154 != 0x00);
	goto l08CF946E;
}

// 08CF9F90: Register (ptr32 Eq_1183) fn08CF9F90(Register (ptr32 Eq_1183) eax, Register up32 edx, Stack uint32 dwArg04, Stack word32 dwArg08, Stack byte bArg0C, Stack word32 dwArg10, Stack (ptr32 Eq_1189) dwArg14)
// Called from:
//      fn08CFA28E
struct Eq_1183 * fn08CF9F90(struct Eq_1183 * eax, up32 edx, uint32 dwArg04, word32 dwArg08, byte bArg0C, word32 dwArg10, union Eq_1189 * dwArg14)
{
	struct Eq_1190 * ecx_19 = eax->ptr0010;
	word32 edi_20 = ecx_19->dw0008;
	word32 ebp_22 = ecx_19->dw0000;
	struct Eq_1183 * eax_122 = null;
	if (eax->dw0038 <= dwArg04)
		return eax_122;
	struct Eq_1208 * edi_29 = (dwArg04 << 0x04) + eax->dw0034;
	word32 dwLoc10_191 = edi_20 + edi_29->dw0004;
	if (edi_29->dw0004 > ecx_19->dw000C)
		return eax_122;
	up32 ecx_36 = edi_29->dw0000;
	if (ecx_36 >= eax->dw0030)
		return eax_122;
	word32 eax_39 = eax->dw002C;
	if (dwArg04 != 0x00)
	{
		byte * ebp_44 = eax_39 + ecx_36;
		if (*ebp_44 == 0x00 || edi_29->w000E != 0x00)
			goto l08CFA08A;
		<anonymous> * eax_49 = eax->ptr00C4;
		if (eax_49 == null)
		{
l08CFA029:
			struct Eq_1264 * eax_67 = eax->ptr0000;
			word32 eax_76;
			eax_67->ptr0028();
			dwLoc10_191 = eax_76;
			if (eax_76 == 0x00)
			{
				struct Eq_1190 * eax_114 = eax->ptr0010;
				ui32 ecx_113 = 0x00;
				if (eax_114->dw0024 > 0x00)
				{
					do
					{
						word32 eax_96 = eax_114->ptr0028[ecx_268];
						word32 eax_104;
						eax->ptr0000->ptr0028();
						if (eax_104 != 0x00)
						{
							dwLoc10_191 = eax_104;
							goto l08CFA08A;
						}
						ecx_113 = ecx_268 + 0x01;
						eax_114 = eax->ptr0010;
						ecx_268 = ecx_113;
					} while (ecx_268 + 0x01 < eax_114->dw0024);
				}
				eax_122 = null;
				if ((word32) edi_29->b000C >> 0x04 != 0x02)
					return eax_122;
			}
			goto l08CFA08A;
		}
		word32 eax_56;
		eax_49();
		dwLoc10_191 = eax_56;
		if (eax_56 == 0x00)
			goto l08CFA029;
	}
l08CFA08A:
	word32 * eax_131 = dwArg08 - ebp_22 + edi_20;
	if (edx != 0x01)
	{
		if (edx > 0x07)
		{
			if (edx != 0x08)
				eax_122 = (uint32) (int8) (edx == 0x00);
			else if (bArg0C != 0x00)
			{
				*eax_131 = (const char *) dwArg14 + dwArg10;
				eax_122 = (struct Eq_1183 *) 0x01;
			}
			else
			{
				*eax_131 = (const char *) dwArg14 + *eax_131;
				eax_122 = (struct Eq_1183 *) 0x01;
			}
		}
		else
		{
			*eax_131 = dwLoc10_191;
			eax_122 = (struct Eq_1183 *) 0x01;
		}
	}
	else if (bArg0C != 0x00)
	{
		*eax_131 = dwLoc10_191 + dwArg10;
		eax_122 = (struct Eq_1183 *) 0x01;
	}
	else
	{
		*eax_131 += dwLoc10_191;
		eax_122 = (struct Eq_1183 *) 0x01;
	}
	return eax_122;
}

// 08CFA144: Register word32 fn08CFA144(Stack (ptr32 Eq_974) dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      fn08CF91F2
word32 fn08CFA144(struct Eq_974 * dwArg04, byte * dwArg08)
{
	word32 eax_20;
	if (dwArg04 != null)
	{
		int32 edi_19 = dwArg04->dw0010;
		eax_20 = 0x00;
		if (edi_19 <= 0x00)
			return eax_20;
		struct Eq_1378 * esi_23 = dwArg04->ptr0014;
		int32 dwLoc10_80 = 0x00;
		do
		{
			byte * eax_27 = esi_23->t0000;
			byte * edx_29 = dwArg08;
			do
			{
				byte cl_33 = *eax_27;
				if (cl_33 == 0x00)
				{
					eax_20 = esi_23->dw0004;
					return eax_20;
				}
				++eax_27;
				edx_29 = edx_112 + 1;
				edx_112 = edx_29;
			} while (*edx_112 == cl_33);
			int32 v14_49 = dwLoc10_80 + 0x01;
			dwLoc10_80 = v14_49;
			++esi_23;
		} while (v14_49 != edi_19);
	}
	eax_20 = 0x00;
	return eax_20;
}

// 08CFA1AF: void fn08CFA1AF(Stack (ptr32 Eq_977) dwArg04, Stack (ptr32 Eq_974) dwArg08)
// Called from:
//      fn08CF91F2
//      fn08CFA28E
void fn08CFA1AF(struct Eq_977 * dwArg04, struct Eq_974 * dwArg08)
{
	if (dwArg08 == null)
		return;
	<anonymous> * edx_19[] = dwArg08->ptr001C;
	if (edx_19 == null)
	{
l08CFA209:
		<anonymous> * eax_61 = dwArg08->ptr0018;
		if (eax_61 != null)
		{
			word32 edx_69;
			word32 eax_70;
			word32 ecx_71;
			eax_61();
		}
		word32 edx_109[] = dwArg08->ptr0028;
		if (edx_109 != null)
		{
			int32 ecx_105 = dwArg08->dw0024;
			if (ecx_105 > 0x00)
			{
				int32 edi_104 = 0x00;
				do
				{
					int32 ecx_102;
					word32 (* edx_101)[];
					word32 eax_88 = edx_109[edi_104];
					if (eax_88 != 0x00)
					{
						word32 eax_98;
						dwArg04->ptr0018();
						edx_101 = dwArg08->ptr0028;
						ecx_102 = dwArg08->dw0024;
						ecx_105 = ecx_102;
						edx_109 = edx_101;
					}
					++edi_104;
				} while (edi_104 < ecx_105);
			}
			word32 edx_125;
			word32 eax_126;
			word32 ecx_127;
			dwArg04->ptr0004();
		}
		union Eq_1189 * eax_131 = dwArg08->ptr0008;
		if (eax_131 != (union Eq_1189 *) ~0x00)
		{
			uint32 edx_134 = dwArg08->dw000C;
			word32 eax_142;
			word32 ecx_143;
			dwArg04->ptr0010();
		}
		struct Eq_1378 * eax_147 = dwArg08->ptr0014;
		if (eax_147 != null)
		{
			if (dwArg08->dw0010 > 0x00)
			{
				int32 edi_154 = 0x00;
				do
				{
					word32 eax_160 = eax_147[edi_154];
					word32 edx_166;
					word32 ecx_168;
					dwArg04->ptr0004();
					++edi_154;
					eax_147 = dwArg08->ptr0014;
				} while (dwArg08->dw0010 > edi_154);
			}
			word32 edx_185;
			word32 eax_186;
			word32 ecx_187;
			dwArg04->ptr0004();
		}
		word32 edx_195;
		word32 eax_196;
		word32 ecx_197;
		dwArg04->ptr0004();
	}
	else
	{
		Eq_1427 edi_23 = dwArg08->t0020;
		word32 edi_210 = edi_23 - 0x01;
		if (edi_23 < 0x01)
			goto l08CFA209;
		int32 eax_209 = (edi_23 - 0x01) * 0x04;
		while (true)
		{
			int32 eax_53;
			<anonymous> * edx_33 = edx_19[eax_209 / 4];
			if (edx_33 <= (<anonymous> *) ~0x01)
			{
				word32 edx_47;
				word32 ecx_49;
				edx_33();
				--edi_210;
				eax_53 = eax_209 - 0x04;
				eax_209 = eax_53;
				if (edi_210 == ~0x00)
					goto l08CFA209;
			}
			else
			{
				--edi_210;
				eax_209 -= 0x04;
				if (edi_210 == ~0x00)
					goto l08CFA209;
			}
			edx_19 = dwArg08->ptr001C;
		}
	}
}

// 08CFA28E: Register (ptr32 Eq_974) fn08CFA28E(Stack (ptr32 Eq_977) dwArg04, Stack Eq_458 dwArg08, Stack Eq_261 dwArg0C, Stack word32 dwArg10)
// Called from:
//      fn08CF91F2
struct Eq_974 * fn08CFA28E(struct Eq_977 * dwArg04, Eq_458 dwArg08, Eq_261 dwArg0C, word32 dwArg10)
{
	struct Eq_974 * dwLocFC_1754;
	struct Eq_974 * eax_39;
	dwArg04->ptr0000();
	struct Eq_1570 * dwLocC8_1769 = null;
	Eq_1572 dwLocC4_1771 = 0x00;
	<anonymous> * dwLocC0_2681 = null;
	up32 dwLocB4_1758 = 0x00;
	<anonymous> * dwLocBC_2802[] = null;
	Eq_1580 dwLocB8_2803 = 0x00;
	Eq_1582 dwLocA4_2939 = 0x00;
	if (eax_39 == null)
	{
		dwLocFC_1754 = null;
		goto l08CFA392;
	}
	eax_39->ptr0008 = (union Eq_1189 *) ~0x00;
	if (dwArg0C <= 0x3F)
	{
l08CFA38A:
		dwLocFC_1754 = eax_39;
		goto l08CFA392;
	}
	if (*dwArg08 != 0x7F)
	{
l08CFA36C:
		dwLocFC_1754 = eax_39;
		goto l08CFA392;
	}
	if (*((word32) dwArg08 + 1) == 0x45)
	{
		if (*((word32) dwArg08 + 2) != 0x4C)
			goto l08CFA38A;
		if (*((word32) dwArg08 + 3) != 0x46)
			goto l08CFA36C;
		if (*((word32) dwArg08 + 4) == 0x01)
		{
			if (*((word32) dwArg08 + 5) != 0x01)
				goto l08CFA38A;
			if (*((word32) dwArg08 + 6) != 0x01)
				goto l08CFA36C;
			if (*((word32) dwArg08 + 7) == 0x00)
			{
				if (*((word32) dwArg08 + 8) != 0x00)
					goto l08CFA38A;
				if (*((word32) dwArg08 + 16) != 0x03)
					goto l08CFA36C;
				if (*((word32) dwArg08 + 18) == 0x03)
				{
					if (*((word32) dwArg08 + 20) != 0x01)
						goto l08CFA38A;
					if (*((word32) dwArg08 + 40) != 0x34)
						goto l08CFA36C;
					if (*((word32) dwArg08 + 42) == 0x20)
					{
						if (*((word32) dwArg08 + 46) != 0x28)
							goto l08CFA38A;
						int32 edx_83 = *((word32) dwArg08 + 28);
						int32 edi_84 = (word32) *((word32) dwArg08 + 44);
						if (dwArg0C >= (edi_84 << 0x05) + edx_83)
						{
							if (dwArg0C < (word32) (*((word32) dwArg08 + 32)) + (word32) (*((word32) dwArg08 + 48)) * 0x28)
								goto l08CFA38A;
							eax_39->dw0000 = ~0x00;
							if (edi_84 == 0x00)
							{
								dwLocFC_1754 = eax_39;
								goto l08CFA689;
							}
							struct Eq_1705 * edx_106 = (word32) dwArg08 + edx_83;
							Eq_1707 edi_107 = edx_106->dw0004;
							up32 eax_108 = edx_106->dw0010;
							if ((word32) edi_107 + eax_108 > dwArg0C)
								goto l08CFA532;
							if (eax_108 > edx_106->dw0014)
								goto l08CFA38A;
							dwLocFC_1754 = eax_39;
							struct Eq_1721 * eax_116 = &edx_106->dw0014 + 8;
							int32 ecx_117 = 0x00;
l08CFA64D:
							word32 esi_122 = edx_106->dw0000;
							if (esi_122 != 0x01)
							{
								if (esi_122 == 0x02)
								{
									if (dwLocC8_1769 != null)
										goto l08CFA392;
									dwLocC8_1769 = dwArg08 + edi_107;
									dwLocC4_1771 = edx_106->dw0010 >> 0x03;
									++ecx_117;
									++edx_106;
									if (edi_84 <= ecx_117)
									{
l08CFA689:
										if (dwLocB4_1758 == 0x00 || dwLocC8_1769 == null)
											goto l08CFA392;
										dwLocFC_1754->dw0000 &= ~0x0FFF;
										ui32 esi_203 = dwLocB4_1758 - eax_39->dw0000;
										uint32 edi_207 = (esi_203 & ~0x0FFF) + 0x1000;
										int32 ebp_211 = *((word32) dwArg08 + 28);
										word16 ax_216 = *((word32) dwArg08 + 44);
										union Eq_1189 * eax_230;
										dwArg04->ptr0008();
										if (eax_230 == (union Eq_1189 *) ~0x00)
											goto l08CFA38A;
										union Eq_1189 * ecx_239;
										uint32 ebp_240;
										if (edi_207 <= 0x03)
										{
											ecx_239 = eax_230;
											ebp_240 = edi_207;
											goto l08CFA7EA;
										}
										uint32 esi_241 = (esi_203 & ~0x0FFF) + 0x0FFC;
										uint32 ecx_250 = -((eax_230 & 0x0F) >> 0x02);
										uint32 ebp_246 = (esi_241 >> 0x02) + 0x01;
										uint32 ecx_251 = ecx_250 & 0x03;
										if ((ecx_250 & 0x03) > ebp_246)
											ecx_251 = ebp_246;
										uint32 edx_261;
										union Eq_1189 * eax_262;
										if (ecx_251 != 0x00)
										{
											edx_261 = edi_207;
											uint32 esi_265 = 0x00;
											eax_262 = eax_230;
											do
											{
												*eax_262 = 0x00;
												eax_262 = (union Eq_1189 *) ((const char *) eax_262 + 4);
												edx_261 -= 0x04;
												++esi_265;
											} while (ecx_251 > esi_265);
										}
										else
										{
											edx_261 = edi_207;
											eax_262 = eax_230;
										}
										uint32 esi_283 = ebp_246 - ecx_251;
										if ((esi_283 & ~0x03) != 0x00)
										{
											word128 * esi_296 = (const char *) eax_230 + ecx_251 * 0x04;
											uint32 ecx_297 = 0x00;
											do
											{
												*esi_296 = 0x00;
												++ecx_297;
												++esi_296;
											} while (ecx_297 < esi_283 >> 0x02);
											eax_262 = (union Eq_1189 *) ((const char *) eax_262 + (esi_283 & ~0x03) * 0x04);
											edx_261 += -(esi_283 & ~0x03) * 0x04;
											if (esi_283 == (esi_283 & ~0x03))
											{
l08CFA7D6:
												ecx_239 = (union Eq_1189 *) ((const char *) eax_230 + ebp_246 * 0x04);
												ebp_240 = esi_241 + -(esi_241 >> 0x02) * 0x04;
l08CFA7EA:
												if (ebp_240 != 0x00)
												{
													ui32 edx_351 = -ecx_239;
													uint32 esi_348 = ebp_240 - 0x01;
													uint32 edx_352 = edx_351 & 0x0F;
													if ((edx_351 & 0x0F) > ebp_240)
														edx_352 = ebp_240;
													union Eq_1189 * eax_1706 = ecx_239;
													if (edx_352 != 0x00)
													{
														uint32 edi_362 = 0x00;
														do
														{
															*eax_1706 = (union Eq_1189 *) 0x00;
															eax_1706 = (union Eq_1189 *) ((const char *) eax_1706 + 1);
															--esi_348;
															++edi_362;
														} while (edx_352 > edi_362);
														if (ebp_240 == edx_352)
															goto l08CFA85B;
													}
													Eq_1933 ebp_381 = ebp_240 - edx_352;
													Eq_1933 ebp_390 = __align(ebp_381, 16);
													if (ebp_390 == 0x00)
													{
l08CFA84B:
														Eq_1958 edx_420 = 0x00;
														Eq_1958 ecx_424 = esi_348 + 0x01;
														do
														{
															Mem427[eax_1706 + edx_420:byte] = 0x00;
															edx_420 = (word32) edx_420.u0 + 1;
														} while (edx_420 != ecx_424);
														goto l08CFA85B;
													}
													word128 * ecx_395 = (const char *) ecx_239 + edx_352;
													uint32 edx_396 = 0x00;
													do
													{
														*ecx_395 = 0x00;
														++edx_396;
														++ecx_395;
													} while (edx_396 < ebp_381 >> 0x04);
													eax_1706 += ebp_390;
													esi_348 -= ebp_390;
													if (ebp_381 != ebp_390)
														goto l08CFA84B;
												}
l08CFA85B:
												eax_39->ptr0008 = eax_230;
												eax_39->dw000C = edi_207;
												if (ax_216 != 0x00)
												{
													struct Eq_1996 * esi_446 = (word32) dwArg08 + ebp_211;
													word32 eax_447 = (word32) ax_216;
													word32 dwLoc0100_1939 = 0x01;
													do
													{
														if (esi_446->dw0000 == 0x01)
														{
															word32 edi_456 = esi_446->dw0014;
															if (edi_456 == 0x00)
																goto l08CFA89B;
															ui32 edx_466 = esi_446->dw0018;
															Eq_2934 edi_482[] = esi_446->dw0010;
															union Eq_2029 * ebp_465 = (const char *) eax_230 + esi_446->dw0008 - eax_39->dw0000;
															ui32 ecx_480 = (uint32) (int8) (((byte) edx_466 & 0x04) != 0x00) | edx_466 & 0x02 | -(edx_466 & 0x01) & 0x04;
															Eq_2934 (* dwLocFC_1944)[] = edi_482;
															word32 * edi_485 = (word32) dwArg08 + esi_446->dw0004;
															union Eq_2029 * edx_1707 = ebp_465;
															if (edi_482 > (Eq_2934 (*)[]) 0x03)
															{
																Eq_2934 (* ecx_518)[];
																union Eq_2029 * edx_524;
																word32 * eax_523;
																uint32 eax_491 = edi_482 - 0x04 >> 0x02;
																uint32 ecx_495 = eax_491 + 0x01 >> 0x02;
																uint32 eax_496 = eax_491 + 0x01 & 0x7FFFFFFC;
																if (eax_496 != 0x00 && ((int8) (eax_491 > ~0x09) & ((int8) (ebp_465 > edi_485 + 4) | (int8) (edi_485 > (const char *) ebp_465 + 16))) != 0x00)
																{
																	int32 eax_526 = 0x00;
																	uint32 edx_527 = 0x00;
																	do
																	{
																		*((const char *) ebp_465 + eax_526) = edi_485[eax_526];
																		++edx_527;
																		eax_526 += 0x10;
																	} while (edx_527 < ecx_495);
																	eax_523 = edi_485 + eax_496 * 0x04;
																	union Eq_2029 * edx_547 = (const char *) ebp_465 + eax_496 * 0x04;
																	ecx_518 = (Eq_2934 (*)[]) (edi_482 + (-eax_496 * 0x04) / 16);
																	if (eax_496 == eax_491 + 0x01)
																		goto l08CFA9B7;
																	edx_524 = edx_547;
																}
																else
																{
																	ecx_518 = edi_482;
																	eax_523 = edi_485;
																	edx_524 = ebp_465;
																}
																do
																{
																	*edx_524 = *eax_523;
																	edx_524 = (union Eq_2029 *) ((const char *) edx_524 + 4);
																	++eax_523;
																	ecx_518 -= 0x04;
																} while (ecx_518 > (Eq_2934 (*)[]) 0x03);
l08CFA9B7:
																edx_1707 = (union Eq_2029 *) ((const char *) ebp_465 + (eax_491 + 0x01) * 0x04);
																edi_485 += (eax_491 + 0x01) * 0x04;
																dwLocFC_1944 = edi_482 & 0x03;
															}
															if (dwLocFC_1944 != null)
															{
																Eq_2934 (* eax_592)[] = null;
																do
																{
																	Mem604[edx_1707 + eax_592:byte] = Mem600[edi_485 + eax_592:byte];
																	++eax_592;
																} while (dwLocFC_1944 != eax_592);
															}
															if (ecx_480 != 0x03)
															{
																word32 eax_639;
																dwArg04->ptr000C();
																if (eax_639 == ~0x00)
																	goto l08CFA38A;
															}
														}
l08CFA89B:
														word32 v29_649 = dwLoc0100_1939 + 0x01;
														++esi_446;
														dwLoc0100_1939 = v29_649;
													} while (v29_649 != eax_447 + 0x01);
												}
												struct Eq_1570 * eax_656 = dwLocC8_1769;
												dwLocFC_1754 = eax_39;
												union Eq_1189 * ebp_660 = eax_39->ptr0008;
												Eq_1572 ecx_1710 = 0x00;
												if (dwLocC4_1771 <= 0x00)
												{
l08CFAAB0:
													if (true || (true || (true || (true || *((union Eq_2159 *) 0x04) != 0x10))))
														goto l08CFA392;
													word32 eax_724 = Mem722[0x04:word32] + dwArg08;
													if (false)
													{
														if (true || (true || *((union Eq_2159 *) 0x04) != 0x0C))
															goto l08CFA392;
														Eq_2159 ebp_740 = *(union Eq_2159 *) 0x04;
														uint32 edx_744 = SLICE(ebp_740 *64 ~0x55555554, word32, 32);
														if (ebp_740 != ((edx_744 >> 0x03) * 0x02 + (edx_744 >> 0x03)) * 0x04 || ebp_740 + Mem725[0x04:word32] >=u dwArg0C)
															goto l08CFA392;
													}
													if (false)
													{
														if (true || (true || *((union Eq_2159 *) 0x04) != 0x08))
															goto l08CFA392;
														Eq_2159 edx_771 = *(union Eq_2159 *) 0x04;
														if (((byte) edx_771 & 0x07) != 0x00 || edx_771 + Mem725[0x04:word32] >=u dwArg0C)
															goto l08CFA392;
													}
													if (false)
													{
														if (true || true)
															goto l08CFA392;
														Eq_2159 edi_793 = *(union Eq_2159 *) 0x04;
														if (Mem725[0x04:word32] + edi_793 >=u dwArg0C)
															goto l08CFA392;
														Eq_2159 eax_798 = *(union Eq_2159 *) 0x04;
														if (eax_798 != 0x11)
														{
															if (eax_798 != 0x07 || (true || *((union Eq_2159 *) 0x04) != 0x0C))
																goto l08CFA392;
															uint32 edx_822 = SLICE(edi_793 *64 ~0x55555554, word32, 32);
															if (edi_793 != ((edx_822 >> 0x03) * 0x02 + (edx_822 >> 0x03)) * 0x04)
																goto l08CFA392;
														}
														else if (true || (*((union Eq_2159 *) 0x04) != 0x08 || (edi_793 & 0x07) != 0x00))
															goto l08CFA392;
													}
													Eq_2159 eax_834 = *(union Eq_2159 *) 0x04;
													word32 edx_841 = dwArg08 + Mem836[0x04:word32];
													if (eax_834 == 0x00 || (Mem842[0x04:word32] + eax_834 >u dwArg0C || (*edx_841 != 0x00 || *((word32) eax_834 + (edx_841 - 0x01)) != 0x00)))
														goto l08CFA392;
													if (false)
														dwLocC0_2681 = Mem842[0x04:word32] + ebp_660 - Mem842[eax_39 + 0x00:word32];
													if (false)
														Mem876[eax_39 + 0x18:word32] = Mem866[0x04:word32] + ebp_660 - Mem866[eax_39 + 0x00:word32];
													if (false)
													{
														if (true)
															goto l08CFA392;
														Eq_2159 ecx_887 = *(union Eq_2159 *) 0x04;
														if (ecx_887 == 0x00 || ecx_887 > 0xFFFF)
															goto l08CFA392;
														dwLocBC_2802 = Mem878[0x04:word32] + ebp_660 - Mem878[eax_39 + 0x00:word32];
														dwLocB8_2803 = *(union Eq_2159 *) 0x04 >> 0x02;
													}
													if (true)
													{
l08CFAD52:
														up32 eax_931 = *((word32) dwArg08 + 32);
														int32 edx_932 = (word32) *((word32) dwArg08 + 48);
														if (edx_932 != 0x00)
														{
															word32 dwLocF4_2934;
															struct Eq_2394 * eax_1670 = (word32) dwArg08 + eax_931;
															if (false)
															{
																dwLocF4_2934 = 0x00;
																int32 edx_1009 = 0x00;
l08CFADAA:
																uint32 ecx_984 = eax_1670->dw0014;
																Eq_2159 esi_983 = eax_1670->dw0010;
																byte cl_998 = (byte) ecx_984;
																Eq_261 edi_985 = (word32) esi_983 + ecx_984;
																if (dwArg0C < edi_985)
																{
																	if (eax_1670->dw0004 != 0x08)
																		goto l08CFA392;
																}
																else if (eax_1670->dw0004 == 11)
																{
																	if (esi_983 != *((union Eq_2159 *) 0x04) || (dwArg0C <= edi_985 || (eax_1670->dw0024 != 0x10 || (cl_998 & 0x0F) != 0x00)))
																		goto l08CFA392;
																	dwLocA4_2939 = ecx_984 >> 0x04;
																	dwLocF4_2934 = 0x01;
																}
																++edx_1009;
																if (edx_932 > edx_1009)
																{
																	++eax_1670;
																	goto l08CFADAA;
																}
															}
															else
															{
																int32 ecx_944 = 0x00;
																while (true)
																{
																	if (dwArg0C >= eax_1670->dw0014 + eax_1670->dw0010)
																	{
																		if (eax_1670->dw0004 == 11)
																			goto l08CFA392;
																	}
																	else if (eax_1670->dw0004 != 0x08)
																		goto l08CFA392;
																	++ecx_944;
																	if (edx_932 <= ecx_944)
																		break;
																	++eax_1670;
																}
																dwLocF4_2934 = 0x00;
															}
															if (dwLocF4_2934 != 0x00)
															{
l08CFA3D0:
																int32 ecx_1030 = eax_39->dw0024;
																struct Eq_1570 * esi_1032 = dwLocC8_1769;
																if (ecx_1030 != 0x00)
																{
																	if (true)
																	{
																		eax_39->dw0024 = 0x00;
																		word32 (* eax_1084)[];
																		dwArg04->ptr0000();
																		eax_39->ptr0028 = eax_1084;
																		struct Eq_974 * eax_1089 = eax_39;
																		dwLocFC_1754 = eax_39;
																		if (eax_39->ptr0028 != null && dwLocC4_1771 > 0x00)
																		{
																			Eq_1572 edi_1097 = 0x00;
																			do
																			{
																				if (esi_1032->dw0000 == 0x01)
																				{
																					Eq_2159 edx_1105 = esi_1032->dw0004;
																					if (edx_1105 >= eax_834)
																						break;
																					word32 edx_1110 = edx_1105 + edx_841;
																					word32 eax_1117;
																					dwArg04->ptr0014();
																					if (eax_1117 == 0x00)
																						goto l08CFA532;
																					int32 ebp_1127 = eax_39->dw0024;
																					eax_39->ptr0028[ebp_1127] = eax_1117;
																					eax_39->dw0024 = ebp_1127 + 0x01;
																					eax_1089 = eax_39;
																					if (ecx_1030 == eax_39->dw0024)
																						goto l08CFA4AF;
																				}
																				edi_1097 = (word32) edi_1097 + 1;
																				++esi_1032;
																			} while (edi_1097 != dwLocC4_1771);
																			dwLocFC_1754 = eax_1089;
																		}
																	}
																}
																else
																{
l08CFA4AF:
																	if (false)
																	{
																		Eq_2159 ecx_1158 = *(union Eq_2159 *) 0x04;
																		uint32 edx_1165 = SLICE(*(union Eq_2159 *) 0x04 *64 ~0x55555554, word32, 32);
																		union Eq_1189 * ebp_1164 = eax_39->ptr0008;
																		if (edx_1165 >> 0x03 != 0x00)
																		{
																			word32 esi_1170 = dwArg08 + ecx_1158;
																			uint32 edi_1171 = 0x00;
																			do
																			{
																				uint32 eax_1176 = esi_1170->dw0004;
																				if (fn08CF9F90(fp - 220, (word32) (byte) eax_1176, eax_1176 >> 0x08, esi_1170->dw0000, 0x01, esi_1170->dw0008, ebp_1164) == 0x00)
																					goto l08CFA532;
																				++edi_1171;
																				++esi_1170;
																			} while (edi_1171 != edx_1165 >> 0x03);
																		}
																	}
																	if (false)
																	{
																		Eq_2159 edx_1213 = *(union Eq_2159 *) 0x04;
																		Eq_2159 eax_1214 = *(union Eq_2159 *) 0x04;
																		union Eq_1189 * ebp_1217 = eax_39->ptr0008;
																		if (eax_1214 >> 0x03 != 0x00)
																		{
																			word32 esi_1222 = dwArg08 + edx_1213;
																			uint32 edi_1223 = 0x00;
																			do
																			{
																				uint32 eax_1228 = esi_1222->dw0004;
																				if (fn08CF9F90(fp - 220, (word32) (byte) eax_1228, eax_1228 >> 0x08, esi_1222->dw0000, 0x00, 0x00, ebp_1217) == 0x00)
																					goto l08CFA532;
																				++edi_1223;
																				++esi_1222;
																			} while (edi_1223 != eax_1214 >> 0x03);
																		}
																	}
																	if (false)
																	{
																		Eq_2159 ecx_1266 = *(union Eq_2159 *) 0x04;
																		Eq_2159 eax_1267 = *(union Eq_2159 *) 0x04;
																		if (*(union Eq_2159 *) 0x04 != 0x07)
																		{
																			union Eq_1189 * ebp_1317 = eax_39->ptr0008;
																			if (eax_1267 >> 0x03 != 0x00)
																			{
																				word32 esi_1322 = dwArg08 + ecx_1266;
																				uint32 edi_1323 = 0x00;
																				do
																				{
																					uint32 eax_1328 = esi_1322->dw0004;
																					if (fn08CF9F90(fp - 220, (word32) (byte) eax_1328, eax_1328 >> 0x08, esi_1322->dw0000, 0x00, 0x00, ebp_1317) == 0x00)
																						goto l08CFA532;
																					++edi_1323;
																					++esi_1322;
																				} while (edi_1323 != eax_1267 >> 0x03);
																			}
																		}
																		else
																		{
																			uint32 edx_1274 = SLICE(eax_1267 *64 ~0x55555554, word32, 32);
																			union Eq_1189 * ebp_1273 = eax_39->ptr0008;
																			if (edx_1274 >> 0x03 != 0x00)
																			{
																				word32 esi_1279 = dwArg08 + ecx_1266;
																				uint32 edi_1280 = 0x00;
																				do
																				{
																					uint32 eax_1285 = esi_1279->dw0004;
																					if (fn08CF9F90(fp - 220, (word32) (byte) eax_1285, eax_1285 >> 0x08, esi_1279->dw0000, 0x01, esi_1279->dw0008, ebp_1273) == 0x00)
																						goto l08CFA532;
																					++edi_1280;
																					++esi_1279;
																				} while (edi_1280 != edx_1274 >> 0x03);
																			}
																		}
																	}
																	<anonymous> * dwLocEC_3580;
																	if (dwLocA4_2939 <= 0x00)
																	{
																		dwLocEC_3580 = dwLocC0_2681;
																		goto l08CFB009;
																	}
																	dwLocFC_1754 = eax_39;
																	union Eq_1189 * esi_1370 = eax_39->ptr0008;
																	uint32 eax_1371 = eax_724->dw0004;
																	uint32 ebp_1372 = eax_39->dw000C;
																	if (ebp_1372 >= eax_1371)
																	{
																		Eq_2159 edx_1375 = eax_724->dw0000;
																		if (eax_834 > edx_1375)
																		{
																			<anonymous> * dwLoc0100_3605 = (const char *) esi_1370 + eax_1371;
																			dwLocEC_3580 = dwLocC0_2681;
																			word32 eax_1389 = eax_724 + 0x10;
																			Eq_1582 ecx_1390 = 0x01;
																			int32 dwLocE4_3627 = 0x00;
																			do
																			{
																				if (Mem1395[edx_841 + edx_1375:byte] != 0x00)
																				{
																					word16 dx_1404 = Mem1395[eax_724 + 0x0E + (eax_1389 - (eax_724 + 0x10)):word16];
																					if (dx_1404 != 0x00 && (dx_1404 != ~0x0E && dwLoc0100_3605 != dwLocC0_2681))
																						dwLocE4_3627 += (word32) (int8) (dwLoc0100_3605 != eax_39->ptr0018);
																				}
																				ecx_1390 = (word32) ecx_1390.u0 + 1;
																				if (ecx_1390 > dwLocA4_2939)
																				{
																					if (dwLocE4_3627 == 0x00)
																					{
l08CFB009:
																						if (dwLocEC_3580 != null)
																							dwLocEC_3580();
																						if (dwLocBC_2802 == null)
																							return eax_39;
																						Eq_1580 ecx_1619 = dwLocB8_2803;
																						if (dwLocB8_2803 <= 0x00)
																							return eax_39;
																						Eq_1580 esi_1622 = 0x00;
																						while (true)
																						{
																							<anonymous> * eax_1628 = dwLocBC_2802[esi_1622];
																							if (eax_1628 <= (<anonymous> *) ~0x01)
																							{
																								eax_1628();
																								ecx_1619 = dwLocB8_2803;
																								esi_1622 = (word32) esi_1622 + 1;
																								if (esi_1622 >= dwLocB8_2803)
																									return eax_39;
																							}
																							else
																							{
																								esi_1622 = (word32) esi_1622.u0 + 1;
																								if (esi_1622 >= ecx_1619)
																									return eax_39;
																							}
																						}
																					}
																					struct Eq_1378 * eax_1464;
																					dwArg04->ptr0000();
																					eax_39->ptr0014 = eax_1464;
																					dwLocFC_1754 = eax_39;
																					if (eax_39->ptr0014 == null)
																						break;
																					struct Eq_2162 * edi_1476 = eax_724;
																					Eq_1582 eax_1477 = dwLocA4_2939;
																					if (dwLocA4_2939 <= 0x00)
																					{
																						dwLocEC_3580 = dwLocC0_2681;
																						goto l08CFB009;
																					}
																					dwLocEC_3580 = dwLocC0_2681;
																					Eq_1582 ebp_1484 = 0x01;
																					struct Eq_974 * edx_1485 = eax_39;
l08CFB0F2:
																					union Eq_1189 * ecx_1488 = edx_1485->ptr0008;
																					word32 esi_1492 = edi_1476->dw0004;
																					byte * esi_1495 = edx_841 + edi_1476->dw0000;
																					if (*esi_1495 != 0x00)
																					{
																						word16 cx_1499 = edi_1476->w000E;
																						if (cx_1499 != 0x00 && cx_1499 != ~0x0E)
																						{
																							<anonymous> * ecx_1506 = (const char *) ecx_1488 + esi_1492;
																							if (ecx_1506 != dwLocEC_3580 && ecx_1506 != edx_1485->ptr0018)
																							{
																								struct Eq_2835 * v26_1519 = edx_1485->ptr0014 + (edx_1485->dw0010 << 0x03) / 8;
																								int32 eax_1521 = 0x00;
																								do
																									++eax_1521;
																								while (esi_1495[eax_1521] != 0x00);
																								byte eax_1541[];
																								dwArg04->ptr0000();
																								v26_1519->ptr0000 = eax_1541;
																								if (eax_1541 == null)
																									goto l08CFA532;
																								int32 edx_1550 = 0x00;
																								do
																								{
																									byte cl_1557 = esi_1495[edx_1550];
																									eax_1541[edx_1550] = cl_1557;
																									++edx_1550;
																								} while (cl_1557 != 0x00);
																								v26_1519->ptr0004 = ecx_1506;
																								++eax_39->dw0010;
																								edx_1485 = eax_39;
																								if (eax_39->dw0010 == dwLocE4_3627)
																								{
																									dwLocEC_3580 = dwLocC0_2681;
																									goto l08CFB009;
																								}
																								dwLocEC_3580 = dwLocC0_2681;
																								eax_1477 = dwLocA4_2939;
																							}
																						}
																					}
																					ebp_1484 = (word32) ebp_1484.u0 + 1;
																					if (ebp_1484 > eax_1477)
																						goto l08CFB009;
																					edi_1476 += 0x10;
																					goto l08CFB0F2;
																				}
																				uint32 edx_1430 = eax_1389->dw0004;
																				dwLoc0100_3605 = (<anonymous> *) ((const char *) esi_1370 + edx_1430);
																				if (ebp_1372 < edx_1430)
																					break;
																				eax_1389 += 0x10;
																				edx_1375 = eax_1389->dwFFFFFFF0;
																			} while (eax_834 > edx_1375);
																		}
																	}
																}
																goto l08CFA392;
															}
														}
														if (false)
															goto l08CFA392;
														goto l08CFA3D0;
													}
													if (true)
														goto l08CFA392;
													Eq_2159 edx_912 = *(union Eq_2159 *) 0x04;
													if (edx_912 != 0x00 && edx_912 <= 0xFFFF)
													{
														Mem922[eax_39 + 0x1C:word32] = Mem903[0x04:word32] + ebp_660 - Mem903[eax_39 + 0x00:word32];
														eax_39->t0020 = *(union Eq_2159 *) 0x04 >> 0x02;
														goto l08CFAD52;
													}
l08CFA392:
													dwLocFC_1754->ptr0018 = null;
													fn08CFA1AF(dwArg04, dwLocFC_1754);
													return null;
												}
l08CFAA9A:
												up32 edx_667 = eax_656->dw0000;
												if (edx_667 != 0x00)
												{
													if (edx_667 == 0x01)
													{
														++eax_39->dw0024;
														ecx_1710 = (word32) ecx_1710 + 1;
														if (ecx_1710 == dwLocC4_1771)
															goto l08CFAAB0;
l08CFAA97:
														++eax_656;
														goto l08CFAA9A;
													}
													if (edx_667 <= 33)
													{
														if ((fp - 0xD0)[edx_667 + 0x0C] != 0x00)
															goto l08CFA392;
														(fp - 0xD0)[edx_667 + 0x0C].dw0000 = eax_656;
													}
												}
												ecx_1710 = (word32) ecx_1710 + 1;
												if (ecx_1710 == dwLocC4_1771)
													goto l08CFAAB0;
												goto l08CFAA97;
											}
										}
										do
										{
											*eax_262 = 0x00;
											eax_262 = (union Eq_1189 *) ((const char *) eax_262 + 4);
											edx_261 -= 0x04;
										} while (edx_261 > 0x03);
										goto l08CFA7D6;
									}
l08CFA62E:
									edi_107 = eax_116->dwFFFFFFF0;
									up32 esi_179 = eax_116->dwFFFFFFFC;
									if (dwArg0C < (word32) edi_107 + esi_179)
										goto l08CFA392;
									++eax_116;
									if (esi_179 > eax_116->dwFFFFFFE0)
										goto l08CFA392;
									goto l08CFA64D;
								}
							}
							else
							{
								up32 esi_125 = edx_106->dw0014;
								if (esi_125 != 0x00)
								{
									uint32 edi_129 = edx_106->dw0008;
									up32 esi_130 = esi_125 + edi_129;
									if (esi_130 > dwLocB4_1758)
									{
										dwLocB4_1758 = esi_130;
										edi_129 = edx_106->dw0008;
									}
									if (dwLocFC_1754->dw0000 > edi_129)
									{
										dwLocFC_1754->dw0000 = edi_129;
										dwLocFC_1754 = eax_39;
									}
								}
							}
							++ecx_117;
							++edx_106;
							if (edi_84 <= ecx_117)
								goto l08CFA689;
							goto l08CFA62E;
						}
					}
				}
			}
		}
	}
l08CFA532:
	dwLocFC_1754 = eax_39;
	goto l08CFA392;
}

